= 管理节点基于模拟器的Integration Test框架

== 前言

作为产品型的 IaaS 项目，ZStack 非常重视测试，我们要求每个功能、用户场景都有对应的测试用例覆盖。ZStack 的测试有多种维度，本文介绍后端 Java 开发人员使用的基于模拟器的 Integration
Test 框架。

ZStack 的运行过程中，实际上是管理节点进程 (Java 编写) 通过 HTTP
PRC 调用控制部署在数据中心各物理设备上的 Agent（Python 或 Golang 编写），如下图：

image:https://raw.githubusercontent.com/zxwing/wiki/master/zstack/ZStack%E5%9F%BA%E4%BA%8E%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84Integration-Test%E6%A1%86%E6%9E%B6/agent.png[image]

在 Integreation Test 中，我们用模拟器（通过内嵌的 Jetty
Server）实现所有 Agent HTTP
RPC 接口，每个用例的 JVM 进程就是一个自包含的 ZStack 环境，如图：

image:https://raw.githubusercontent.com/zxwing/wiki/master/zstack/ZStack%E5%9F%BA%E4%BA%8E%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84Integration-Test%E6%A1%86%E6%9E%B6/simulator.png[image]

== 实例

先看一个实际 https://github.com/zstackio/zstack/blob/master/test/src/test/groovy/org/zstack/test/integration/kvm/lifecycle/OneVmBasicLifeCycleCase.groovy[例子]：

[source,groovy]
----
package org.zstack.test.integration.kvm.lifecycle

import org.springframework.http.HttpEntity
import org.zstack.header.vm.VmInstanceState
import org.zstack.header.vm.VmInstanceVO
import org.zstack.kvm.KVMAgentCommands
import org.zstack.kvm.KVMConstant
import org.zstack.sdk.VmInstanceInventory
import org.zstack.test.integration.kvm.OneVmBasicEnv
import org.zstack.testlib.EnvSpec
import org.zstack.testlib.SubCase
import org.zstack.testlib.VmSpec
import org.zstack.utils.gson.JSONObjectUtil

class OneVmBasicLifeCycleCase extends SubCase {
    EnvSpec env

    def DOC = """
test a VM's start/stop/reboot/destroy/recover operations
"""

    @Override
    void setup() {
        spring {
            sftpBackupStorage()
            localStorage()
            virtualRouter()
            securityGroup()
            kvm()
        }
    }

    @Override
    void environment() {
        env = OneVmBasicEnv.env()
    }

    @Override
    void test() {
        env.create {
            testStopVm()
            testStartVm()
            testRebootVm()
            testDestroyVm()
            testRecoverVm()
        }
    }

    void testRecoverVm() {
        VmSpec spec = env.specByName("vm")

        VmInstanceInventory inv = recoverVmInstance {
            uuid = spec.inventory.uuid
        }

        assert inv.state == VmInstanceState.Stopped.toString()

        // confirm the vm can start after being recovered
        testStartVm()
    }

    void testDestroyVm() {
        VmSpec spec = env.specByName("vm")

        KVMAgentCommands.DestroyVmCmd cmd = null

        env.afterSimulator(KVMConstant.KVM_DESTROY_VM_PATH) { rsp, HttpEntity<String> e ->
            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.DestroyVmCmd.class)
            return rsp
        }

        destroyVmInstance {
            uuid = spec.inventory.uuid
        }

        assert cmd != null
        assert cmd.uuid == spec.inventory.uuid
        VmInstanceVO vmvo = dbFindByUuid(cmd.uuid, VmInstanceVO.class)
        assert vmvo.state == VmInstanceState.Destroyed
    }

    void testRebootVm() {
        // reboot = stop + start
        VmSpec spec = env.specByName("vm")

        KVMAgentCommands.StartVmCmd startCmd = null
        KVMAgentCommands.StopVmCmd stopCmd = null

        env.afterSimulator(KVMConstant.KVM_STOP_VM_PATH) { rsp, HttpEntity<String> e ->
            stopCmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StopVmCmd.class)
            return rsp
        }

        env.afterSimulator(KVMConstant.KVM_START_VM_PATH) { rsp, HttpEntity<String> e ->
            startCmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StartVmCmd.class)
            return rsp
        }

        VmInstanceInventory inv = rebootVmInstance {
            uuid = spec.inventory.uuid
        }

        assert startCmd != null
        assert startCmd.vmInstanceUuid == spec.inventory.uuid
        assert stopCmd != null
        assert stopCmd.uuid == spec.inventory.uuid
        assert inv.state == VmInstanceState.Running.toString()
    }

    void testStartVm() {
        VmSpec spec = env.specByName("vm")

        KVMAgentCommands.StartVmCmd cmd = null

        env.afterSimulator(KVMConstant.KVM_START_VM_PATH) { rsp, HttpEntity<String> e ->
            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StartVmCmd.class)
            return rsp
        }

        VmInstanceInventory inv = startVmInstance {
            uuid = spec.inventory.uuid
        }

        assert cmd != null
        assert cmd.vmInstanceUuid == spec.inventory.uuid
        assert inv.state == VmInstanceState.Running.toString()

        VmInstanceVO vmvo = dbFindByUuid(cmd.vmInstanceUuid, VmInstanceVO.class)
        assert vmvo.state == VmInstanceState.Running
        assert cmd.vmInternalId == vmvo.internalId
        assert cmd.vmName == vmvo.name
        assert cmd.memory == vmvo.memorySize
        assert cmd.cpuNum == vmvo.cpuNum
        //TODO: test socketNum, cpuOnSocket
        assert cmd.rootVolume.installPath == vmvo.rootVolumes.installPath
        assert cmd.useVirtio
        vmvo.vmNics.each { nic ->
            KVMAgentCommands.NicTO to = cmd.nics.find { nic.mac == it.mac }
            assert to != null: "unable to find the nic[mac:${nic.mac}]"
            assert to.deviceId == nic.deviceId
            assert to.useVirtio
            assert to.nicInternalName == nic.internalName
        }
    }

    void testStopVm() {
        VmSpec spec = env.specByName("vm")

        KVMAgentCommands.StopVmCmd cmd = null

        env.afterSimulator(KVMConstant.KVM_STOP_VM_PATH) { rsp, HttpEntity<String> e ->
            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StopVmCmd.class)
            return rsp
        }

        VmInstanceInventory inv = stopVmInstance {
            uuid = spec.inventory.uuid
        }

        assert inv.state == VmInstanceState.Stopped.toString()

        assert cmd != null
        assert cmd.uuid == spec.inventory.uuid

        def vmvo = dbFindByUuid(cmd.uuid, VmInstanceVO.class)
        assert vmvo.state == VmInstanceState.Stopped
    }

    @Override
    void clean() {
        env.delete()
    }
}
----

ZStack 的 Integreation
Test 使用 groovy 编写，通过 JUnit 运行。运行如下命令可以执行该 case：

[source,shell]
----
cd /root/zstack/test
mvn test -Dtest=OneVmBasicLifeCycleCase
----

== 依赖环境

在运行任何 Integration Test，开发者的开发环境需要满足如下条件：

[arabic]
. 从 github 上获得一份 ZStack 源代码
. 系统中安装了 Mariadb 数据库（或 mysql）并运行，且**数据库 root 用户的密码为空**
+
____
Integreation
Test 启动时会部署 ZStack 数据库，需要使用到数据库 root 用户，默认使用空密码，此项可以通过配置文件改变
____
. 系统中已安装了 rabbitmq 并运行，*rabbitmq 的 guest 用户使用默认密码*

我们强烈建议开发者使用一个干净的 CentOS 作为开发环境，**不要**把 Integration
Test 和运行 ZStack 的试验环境放在同一台机器，Integration
Test 运行时部署数据库的操作会导致试验环境的 ZStack 数据库丢失。

== 编写测试用例

=== 构成

所有 Integreation Test（除后文讲到的 Test Suite）都继承 `SubCase` 类，例如：

[source,groovy]
----
class OneVmBasicLifeCycleCase extends SubCase {
----

并实现 4 个抽象函数：

[arabic]
. setup：配置用例，主要用于加载运行用例需要用到的 ZStack 服务和组件
. environment： 构造测试环境，例如创建 zone、cluster，添加 host 等操作
. test：执行具体测试代码
. clean：清理环境 （仅当该 case 在 test suite 中运行时执行，后文详述）

测试用例运行时，上述 4 个函数依次执行，任何一个环节出现错误则测试终止退出（case 在 test
suite 中运行时例外）。

=== 配置测试用例： setup()

ZStack 采用 Spring 框架，通过 XML 文件配置和管理要加载的服务和组件。XML 配置文件存在于两个目录：

[arabic]
. https://github.com/zstackio/zstack/tree/master/conf/springConfigXml[conf]:
包含所有 ZStack 组件的 XML 配置文件
. https://github.com/zstackio/zstack/tree/master/test/src/test/resources/springConfigXml[test/src/test/resources/springConfigXml]：包含测试用例自有的 XML 配置文件（例如有的测试用例可能增加自己组件或服务），以及用于覆盖默认组件的的 XML 配置文件（例如 https://github.com/zstackio/zstack/blob/master/test/src/test/resources/springConfigXml/Kvm.xml[test/src/test/resources/springConfigXml/Kvm.xml]）在测试时就会覆盖默认的 https://github.com/zstackio/zstack/blob/master/conf/springConfigXml/Kvm.xml[conf/springConfigXml/Kvm.xml]
+
____
开发者可以使用覆盖默认组件的 XML 配置文件实现测试时改变默认组件的加载行为
____

在 `setup()` 函数中，我们需要指定该测试用例需要加载哪些组件的 XML 配置文件，这通过 `spring` 函数的 DSL 语法实现，例如：

[source,groovy]
----
    @Override
    void setup() {
        spring {
            sftpBackupStorage()
            localStorage()
            virtualRouter()
            securityGroup()
            kvm()
        }
    }
----

____
这里使用的 DSL 是典型的 https://www.tutorialspoint.com/groovy/groovy_builders.htm[groovy
builder pattern]，在整个 Integreation Test 框架中我们大量使用了该 DSL
pattern。
____

在 `spring` 函数后的 `{}`
body 中，开发者可以通过 `include()` 函数指定要加载的 XML 文件，例如：

[source,groovy]
----
    @Override
    void setup() {
        spring {
            include("Kvm.xml") // 指定 XML 文件名即可，不需要加路径
            include("eip.xml")
        }
    }
----

或者使用 spring
DSL 内置的函数直接加载相关 XML 文件，例如 `kvm()` 就等同于 `include("Kvm.xml")`。目前 spring
DSL 提供如下默认内置函数：

[cols=",",options="header",]
|===
| 函数名 | 描述
|includeAll | 加载系统中所有组件
|includeCoreServices | 加载系统核心服务
|nfsPrimaryStorage | 加载 NFS 主存储服务
|localStorage | 加载本地主存储服务
|vyos | 加载 vyos 云路由服务
|virtualRouter | 加载虚拟路由服务
|sftpBackupStorage | 加载 sftp 备份存储服务
|eip | 加载 eip 服务
|lb | 加载负载均衡服务
|portForwarding | 加载端口转发服务
|kvm | 加载 kvm 服务
|ceph | 加载 ceph 主存储 / 备份存储服务
|smp | 加载 sharedMountPoint 主存储服务
|securityGroup | 加载安全组服务
|===

其中 `includeAll` 不应该被直接使用，开发者应该只加载测试用例使用的组件和服务。`includeCoreServices` 会被 spring
DSL 默认调用，例如：

[source,groovy]
----
    @Override
    void setup() {
        spring {
            // 虽然没有指定任何 XML，spring DSL 仍然会为我们加载核心服务
        }
    }
----

会默认加载 ZStack 核心服务。 https://github.com/zstackio/zstack/blob/0e2b956be2058a0971d52a61763d789948a89169/testlib/src/main/java/org/zstack/testlib/SpringSpec.groovy[SpringSpec.groovy] 包含了核心服务定义：

[source,groovy]
----
    List<String> CORE_SERVICES = [
            "HostManager.xml",
            "ZoneManager.xml",
            "ClusterManager.xml",
            "PrimaryStorageManager.xml",
            "BackupStorageManager.xml",
            "ImageManager.xml",
            "HostAllocatorManager.xml",
            "ConfigurationManager.xml",
            "VolumeManager.xml",
            "NetworkManager.xml",
            "VmInstanceManager.xml",
            "AccountManager.xml",
            "NetworkService.xml",
            "volumeSnapshot.xml",
            "tag.xml",
    ]
----

____
核心服务是指
提供一个基础 IaaS 环境所需要的服务，并非指启动 ZStack 进程所需要的服务。例如我们完全可以启动一个不包含 VmInstanceManager.xml（虚拟机服务）的 ZStack 进程，它仍然工作，例如可以提供物理机相关的 API，但不能提供虚拟机相关 API（因为虚拟机服务没有加载）。
____

核心服务之间大多并不相互依赖，例如 `ZoneManager.xml` 并不依赖于 `HostManager.xml`。当开发人员想细粒度的控制系统加载的服务，可以通过将 `INCLUDE_CORE_SERVICES` 变量设置成 false 以阻止 spring
DSL 自动加载核心服务，例如：

[source,groovy]
----
    @Override
    void setup() {
        INCLUDE_CORE_SERVICES = false // <1>

        spring {
            include("ZoneManager.xml") // <2>
        }
    }
----
<1> 当该变量设置成 false 后，后续的 spring DSL 不会自动加载核心服务
<2> 这里我们只加载跟 zone 相关的服务

spring
DSL 提供的内置函数定义在 https://github.com/zstackio/zstack/blob/0e2b956be2058a0971d52a61763d789948a89169/testlib/src/main/java/org/zstack/testlib/SpringSpec.groovy[SpringSpec.groovy] 中，开发人员可以直接查看。随着后续 ZStack 服务的增加，还会有新的内置函数加入。

=== 构建用例环境：environment()

绝大部分 Integreation
Test 需要构建测试环境，例如要测试停止虚拟机，首先需要一个已经创建好的虚拟机，而创建一个虚拟机又必须事先创建好物理机、主存储、镜像、网络等资源。为了将开发者从构建环境的重复劳动中解放出来，Integreation
Test 框架提供 env DSL 帮助自动创建环境，先看一个例子：

[source,groovy]
----
    EnvSpec myenv

    @Override
    void environment() {
        myenv = env {
            zone {
                name = "zone"

                l2NoVlanNetwork {
                    name = "l2"
                    physicalInterface = "eth0"

                    l3Network {
                        name = "l3"

                        ip {
                            name = "ipr"
                            startIp = "10.223.110.10"
                            endIp = "10.223.110.20"
                            gateway = "10.223.110.1"
                            netmask = "255.255.255.0"
                        }
                    }
                }
            }
        }
    }
----

在这个例子中，我们通过 env
DSL 描述了一个环境，里面包含 zone、l2NoVlanNetwork、l3Network、ip 共 4 个资源。这里 `env()` 函数是 env
DSL 的入口，用于创建一个 `EnvSpec` 对象，开发者可以直接调用其 `create()` 方法部署整个环境：

[source,groovy]
----
  @Override
  void test() {
     myenv.create()
  }
----

env DSL 语法中每个资源可以包含三种成员：

[arabic]
. 参数：用于创建该资源的参数，例如 `name = "zone"` 就指定了创建该 zone 的 name 参数
. 子资源：例如 l2NoVlanNetwork 包含在 zone 中，它就是 zone 的一个子资源
. 函数：通常用于引用其它资源或关联其它资源

当 `create()` 函数调用时，测试框架会遍历 env
DSL 定义的资源树，并调用相应资源的 SDK
API 进行创建，例如 zone 就会使用 SDK 中的 https://github.com/zstackio/zstack/blob/master/sdk/src/main/java/org/zstack/sdk/CreateZoneAction.java[CreateZoneAction] 进行创建。所以 env
DSL 实质是为不同资源在 SDK 中的 Create
Action 的参数赋值。例如 zone 资源包含 `name` 和 `description` 两个参数就对应了 CreateZoneAction 的 name 和 description 参数。

当一个资源被包含在另一个资源的描述中时，被包含的资源称为子资源，例如上例中 l2NoVlanNetwork 是 zone 的子资源。`create()` 方法在遍历资源树时，会先创建父资源，再创建子资源。

当一个资源的创建依赖于其它资源时，需要使用 `useXXX()` 函数通过被依赖资源的名称引用该资源。例如：

[source,groovy]
----
                virtualRouterOffering {
                    name = "vr"
                    memory = SizeUnit.MEGABYTE.toByte(512)
                    cpu = 2
                    useManagementL3Network("pubL3")
                    usePublicL3Network("pubL3")
                    useImage("vr")
                    useAccount("xin")
                }
----

对于 virtualRouterOffering 资源，其 SDK https://github.com/zstackio/zstack/blob/master/sdk/src/main/java/org/zstack/sdk/CreateVirtualRouterOfferingAction.java[CreateVirtualRouterOfferingAction] 需要指定 `managementNetworkUuid`、`publicNetworkUuid`、`imageUuid` 字段，我们用 `useManagementL3Network`、`usePublicL3Network`、`useImage` 去引用名为 pubL3 三层网络和名为 vr 的镜像，它们都是 virtualRouterOffering 的被依赖资源。`create()` 函数遍历资源树时，会首先创建被依赖资源，例如这里会保证 pubL3 三层网络和 vr 镜像先于 virtualRouterOffering 之前创建，并且在创建 virtualRouterOffering 时自动为 `managementNetworkUuid`、`publicNetworkUuid`、`imageUuid` 字段赋上相应资源的 UUID 值。

某些资源（例如 cluster、zone）也可以使用函数去关联其它资源，例如 cluster 可以加载 primary
storage 和 l2network，则需要使用 `attachPrimaryStorage()` 和 `attachL2Network()` 函数：

[source,groovy]
----
                cluster {
                    name = "cluster"
                    hypervisorType = "KVM"

                    kvm {
                        name = "kvm"
                        managementIp = "localhost"
                        username = "root"
                        password = "password"
                        usedMem = 1000
                        totalCpu = 10
                    }

                    attachPrimaryStorage("nfs", "ceph-pri", "local", "smp")
                    attachL2Network("l2")
                }
----

在上例中，cluster 会加载”nfs”, ``ceph-pri'', ``local'',
``smp'' 等 4 个 primary
storage 以及名为”l2”的 l2network，`create()` 函数在遍历资源树时会保证这些资源在 attach 操作时就已经创建完成。

`env()` 函数返回的 `EnvSpec` 对象是 integreation
test 核心对象，通常应该保存成为测试用例的一个成员变量，例如：

[source,groovy]
----
class OneL3OneIpRangeNoIpUsed extends SubCase {
    EnvSpec env

    @Override
    void environment() {
        env = env {
            // 在这里描述环境
        }
    }

    @Override
    void test() {
        env.create {
            // 这里执行测试逻辑
        }
    }
}
----

`EnvSpec.create()` 可以接受一个函数作为参数，具体测试的函数都包含在该函数中运行。

==== env DSL 清单

env DSL 目前支持的所有资源、参数、函数如下：

....
└── env
    ├── account
    │   ├── (field required) name
    │   └── (field required) password
    ├── cephBackupStorage
    │   ├── (field optional) availableCapacity
    │   ├── (field optional) description
    │   ├── (field optional) monAddrs
    │   ├── (field optional) totalCapacity
    │   ├── (field required) fsid
    │   ├── (field required) monUrls
    │   ├── (field required) name
    │   └── (field required) url
    ├── diskOffering
    │   ├── (field optional) allocatorStrategy
    │   ├── (field optional) description
    │   ├── (field required) diskSize
    │   ├── (field required) name
    │   └── (method) useAccount
    ├── instanceOffering
    │   ├── (field optional) allocatorStrategy
    │   ├── (field optional) cpu
    │   ├── (field optional) description
    │   ├── (field optional) memory
    │   ├── (field required) name
    │   └── (method) useAccount
    ├── sftpBackupStorage
    │   ├── (field optional) availableCapacity
    │   ├── (field optional) description
    │   ├── (field optional) hostname
    │   ├── (field optional) password
    │   ├── (field optional) totalCapacity
    │   ├── (field optional) username
    │   ├── (field required) name
    │   └── (field required) url
    ├── vm
    │   ├── (field optional) description
    │   ├── (field required) name
    │   ├── (method) useAccount
    │   ├── (method) useCluster
    │   ├── (method) useDefaultL3Network
    │   ├── (method) useDiskOfferings
    │   ├── (method) useHost
    │   ├── (method) useImage
    │   ├── (method) useInstanceOffering
    │   ├── (method) useL3Networks
    │   └── (method) useRootDiskOffering
    └── zone
        ├── (field optional) description
        ├── (field required) name
        ├── (method) attachBackupStorage
        ├── cephPrimaryStorage
        │   ├── (field optional) availableCapacity
        │   ├── (field optional) description
        │   ├── (field optional) monAddrs
        │   ├── (field optional) totalCapacity
        │   ├── (field required) fsid
        │   ├── (field required) monUrls
        │   ├── (field required) name
        │   └── (field required) url
        ├── cluster
        │   ├── (field optional) description
        │   ├── (field required) hypervisorType
        │   ├── (field required) name
        │   ├── (method) attachL2Network
        │   ├── (method) attachPrimaryStorage
        │   └── kvm
        │       ├── (field optional) description
        │       ├── (field optional) managementIp
        │       ├── (field optional) totalCpu
        │       ├── (field optional) totalMem
        │       ├── (field optional) usedCpu
        │       ├── (field optional) usedMem
        │       ├── (field required) name
        │       ├── (field required) password
        │       └── (field required) username
        ├── eip
        │   ├── (field optional) description
        │   ├── (field optional) requiredIp
        │   ├── (field required) name
        │   ├── (method) useAccount
        │   ├── (method) useVip
        │   └── (method) useVmNic
        ├── l2NoVlanNetwork
        │   ├── (field optional) description
        │   ├── (field required) name
        │   └── (field required) physicalInterface
        ├── l2VlanNetwork
        │   ├── (field optional) description
        │   ├── (field required) name
        │   ├── (field required) physicalInterface
        │   └── (field required) vlan
        ├── lb
        │   ├── (field optional) description
        │   ├── (field required) name
        │   ├── (method) useAccount
        │   ├── (method) useVip
        │   └── listener
        │       ├── (field optional) description
        │       ├── (field required) instancePort
        │       ├── (field required) loadBalancerPort
        │       ├── (field required) name
        │       ├── (field required) protocol
        │       └── (method) useAccount
        ├── localPrimaryStorage
        │   ├── (field optional) availableCapacity
        │   ├── (field optional) description
        │   ├── (field optional) totalCapacity
        │   ├── (field required) name
        │   └── (field required) url
        ├── nfsPrimaryStorage
        │   ├── (field optional) availableCapacity
        │   ├── (field optional) description
        │   ├── (field optional) totalCapacity
        │   ├── (field required) name
        │   └── (field required) url
        ├── portForwarding
        │   ├── (field optional) allowedCidr
        │   ├── (field optional) description
        │   ├── (field required) name
        │   ├── (field required) privatePortEnd
        │   ├── (field required) privatePortStart
        │   ├── (field required) protocolType
        │   ├── (field required) vipPortEnd
        │   ├── (field required) vipPortStart
        │   ├── (method) useAccount
        │   ├── (method) useVip
        │   └── (method) useVmNic
        ├── securityGroup
        │   ├── (field optional) description
        │   ├── (field required) name
        │   ├── (method) attachL3Network
        │   ├── (method) useAccount
        │   ├── (method) useVmNic
        │   └── rule
        │       ├── (field optional) allowedCidr
        │       ├── (field required) endPort
        │       ├── (field required) protocol
        │       ├── (field required) startPort
        │       └── (field required) type
        ├── smpPrimaryStorage
        │   ├── (field optional) availableCapacity
        │   ├── (field optional) description
        │   ├── (field optional) totalCapacity
        │   ├── (field required) name
        │   └── (field required) url
        └── virtualRouterOffering
            ├── (field optional) allocatorStrategy
            ├── (field optional) cpu
            ├── (field optional) description
            ├── (field optional) isDefault
            ├── (field optional) memory
            ├── (field required) name
            ├── (method) useAccount
            ├── (method) useImage
            ├── (method) useManagementL3Network
            └── (method) usePublicL3Network

....

=== 执行测试逻辑：test()

具体的测试逻辑包含在 `test()` 函数中，作为 integreation
test，开发人员应该更多从 API 层面验证程序功能。

==== 用函数名作为注释

一个 integreation
test 通常包含多个程序逻辑的验证，相互混杂在一起常常让阅读代码的人不能直观的了解测试逻辑。ZStack 要求**每个独立的测试逻辑都封装到一个函数中，并使用函数名作为测试逻辑的注释**。例如：

[source,groovy]
----
    void useIpRangeUuidWithStartBeyondTheEndIp() {
        IpRangeSpec ipr = env.specByName("ipr")

        List<FreeIpInventory> freeIps = getFreeIpOfIpRange {
            ipRangeUuid = ipr.inventory.uuid
            start = "10.223.110.21"
        }

        assert freeIps.size() == 0
    }
----

该函数包含在 `org.zstack.test.integration.l3network.getfreeip.OneL3OneIpRangeNoIpUsed` 类中，通过类名和函数名，我们能够很容易的理解这个函数测试的逻辑是：测试 getfreeip
API，并且使用了一个 l3network 和一个 iprange，目前 iprange 中没有 ip 被占用；通过 iprange
uuid 去获取 freeip 指定 API 的 start 参数，而且该参数已经超过了 iprange 的 end
ip。

命名规则如下：

[arabic]
. 通过 package 名描述测试资源的场景，例如 `getfreeip` 是 l3network 的一个场景，而 `org.zstack.test.integration.kvm.lifecycle` 是 kvm 的 lifecycle 场景。每个新场景都需要创建一个新的子 package。
. 通过 class 名描述部署环境，例如 `OneL3OneIpRangeNoIpUsed` 和 `OneVmBasicLifeCycleCase` 都能表示大概的部署场景。
. 通过函数名描述测试的具体内容，例如 `useIpRangeUuidWithStartBeyondTheEndIp`、`testStopVm`。
. 如果名字太长，英语中的一些介词可以省略，例如 `useIpRangeUuidWithStartBeyondTheEndIp` 可以省掉 `with`、`the` 变成 `useIpRangeUuidStartBeyondEndIp`。

==== 每个测试函数只包含一个测试场景

测试场景应该进行细粒度分割，保证每个函数中只有一个测试场景，方便阅读，例如下面这个例子只测试停止 VM 一个场景：

[source,groovy]
----
    void testStopVm() {
        VmSpec spec = env.specByName("vm")

        KVMAgentCommands.StopVmCmd cmd = null

        env.afterSimulator(KVMConstant.KVM_STOP_VM_PATH) { rsp, HttpEntity<String> e ->
            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StopVmCmd.class)
            return rsp
        }

        VmInstanceInventory inv = stopVmInstance {
            uuid = spec.inventory.uuid
        }

        assert inv.state == VmInstanceState.Stopped.toString()

        assert cmd != null
        assert cmd.uuid == spec.inventory.uuid

        def vmvo = dbFindByUuid(cmd.uuid, VmInstanceVO.class)
        assert vmvo.state == VmInstanceState.Stopped
    }
----

我们允许调用一个测试场景的函数来验证另一个测试场景。例如测试 recover
VM 这个功能时，我们要确认被 recover 的 VM 可以成功启动，则可以在测试 recover
VM 的函数中调用测试 start VM 的函数进行验证：

[source,groovy]
----
    void testRecoverVm() {
        VmSpec spec = env.specByName("vm")

        VmInstanceInventory inv = recoverVmInstance {
            uuid = spec.inventory.uuid
        }

        assert inv.state == VmInstanceState.Stopped.toString()

        // confirm the vm can start after being recovered
        testStartVm()
    }
----

==== 调用 API

Integreation
Test 中大部分时候是基于 API 对具体场景进行测试。所有测试用例必须使用 ZStack
Java SDK 调用 API，任何其他形式都是禁止的（例如通过 CloudBus 发 API
Message）。为了方便 API 调用，Integreation Test 将所有 Java SDK 封装成了 API
DSL。例如使用 SDK 启动一个云主机，写法为：

[source,groovy]
----
StartVmInstanceAction a = new StartVmInstanceAction()
a.sessionId = "583c56b6352d4399aac23295b1507506"
a.uuid = "36c27e8ff05c4780bf6d2fa65700f22e"
StartVmInstanceAction.Result res = a.call()
assert res.error != null: "API StartVmInstanceAction fails with an error ${res.error}"
VmInstanceInventory vm = res.value.inventory
----

使用 API DSL 代码则简化为：

[source,groovy]
----
VmInstanceInventory inv = startVmInstance {
     uuid = "36c27e8ff05c4780bf6d2fa65700f22e"
     sessionId = "583c56b6352d4399aac23295b1507506"
}
----

API DSL 会自动检查返回值，如果 error 不为空则 assert 异常。

如果一个 API 失败的行为是期望的，可以用 `expect` 函数。`expect` 的第一个参数可以是一个 Throwable
Class，也可以是一个 Throwable Class 的集合：

[source,groovy]
----
    expect(RuntimeException.class) {
        throw new RuntimeException("ok")
    }

    expect([CloudRuntimeException.class, IllegalArgumentException.class]) {
        throw new RuntimeException("ok")
    }

    expect(AssertionError.class) {
        VmInstanceInventory inv = startVmInstance {
            uuid = "36c27e8ff05c4780bf6d2fa65700f22e"
            sessionId = "583c56b6352d4399aac23295b1507506"
        }
    }
----

如果 `expect` 后的函数抛出的异常不是所期望的，`expect` 本身则会抛出一个 Exception 导致测试失败。

____
API
DSL 的函数命名方式很简单，将 SDK 对应类名的 __Action__ 去掉，并且首字母小写就是对应的函数名。例如 StartVmInstanceAction 对应 startVmInstance。使用 Intellij 等 IDE 输入函数名时又自动提示和补全。
____

*由于 API
DSL 会自动检查返回值，如果返回 error 是预期行为并想对 error 进行检查，则不能使用 API
DSL，而要使用 SDK。*

==== 通过 assert 来验证测试结果

测试用例在验证测试结果的时候可以使用 groovy 的 assert 功能来验证结果，例如：

[source,groovy]
----
assert inv.state == VmInstanceState.Stopped.toString()
----

当验证失败时，log 里面也会有详细信息：

....
assert freeIps.size() == 10
       |       |      |
       []      0      false org.codehaus.groovy.runtime.powerassert.PowerAssertionError: assert freeIps.size() == 10
       |       |      |
       []      0      false
    ... suppressed 2 lines
    at org.zstack.test.integration.l3network.getfreeip.OneL3OneIpRangeNoIpUsed.useIpRangeUuidWithStartBeyondTheEndIp(OneL3OneIpRangeNoIpUsed.groovy:76) ~[test-classes/:?]
    ... suppressed 12 lines
    at org.zstack.test.integration.l3network.getfreeip.OneL3OneIpRangeNoIpUsed$_test_closure3.doCall(OneL3OneIpRangeNoIpUsed.groovy:60) ~[test-classes/:?]
    at org.zstack.test.integration.l3network.getfreeip.OneL3OneIpRangeNoIpUsed$_test_closure3.doCall(OneL3OneIpRangeNoIpUsed.groovy) ~[test-classes/:?]
    ... suppressed 12 lines
    at org.zstack.testlib.EnvSpec.create(EnvSpec.groovy:229) ~[testlib-1.9.0.jar:?]
    at org.zstack.testlib.EnvSpec$create.call(Unknown Source) ~[?:?]
....

==== 模拟 agent 行为

ZStack Integreation
Test 最核心功能是通过基于 Jetty 的模拟器模拟真实环境下物理设备上安装的 agent，例如模拟物理机上安装的 KVM
agent。当测试的场景涉及到后端 agent 调用时，我们需要捕获这些 HTTP 请求并进行验证，也可以伪造 agent 返回测试 API 逻辑。

`EnvSpec` 提供 `simulator()` 和 `afterSimulator()` 模拟 agent 行为，两者的区别在于 `simulator()` 会替换测试框架默认的处理函数，而 `afterSimulator()` 允许在默认处理函数执行完后再执行一段额外的逻辑。例如

[source,groovy]
----
env.simulator(KVMConstant.KVM_START_VM_PATH) {
    throw new Exception("fail to start a VM on purpose")
}
----

在上例中，我们通过 `simulator()` 替换掉了框架对 `KVMConstant.KVM_START_VM_PATH` 的默认处理函数，并在我们自己的处理函数中抛出了一个异常来模拟启动 VM 失败的情况。而使用 `afterSimulator()` 则可以在默认处理函数执行完后增加一段逻辑，例如下面例子中，我们捕获了发往 `KVMConstant.KVM_START_VM_PATH` 的命令，并对相关字段进行了验证：

[source,groovy]
----
void testStartVm() {
    VmSpec spec = env.specByName("vm")

    KVMAgentCommands.StartVmCmd cmd = null

    env.afterSimulator(KVMConstant.KVM_START_VM_PATH) { rsp, HttpEntity<String> e ->
        cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StartVmCmd.class)
        return rsp
    }

    VmInstanceInventory inv = startVmInstance {
        uuid = spec.inventory.uuid
    }

    assert cmd != null
    assert cmd.vmInstanceUuid == spec.inventory.uuid
    assert inv.state == VmInstanceState.Running.toString()

    VmInstanceVO vmvo = dbFindByUuid(cmd.vmInstanceUuid, VmInstanceVO.class)
    assert vmvo.state == VmInstanceState.Running
    assert cmd.vmInternalId == vmvo.internalId
    assert cmd.vmName == vmvo.name
    assert cmd.memory == vmvo.memorySize
    assert cmd.cpuNum == vmvo.cpuNum
    //TODO: test socketNum, cpuOnSocket
    assert cmd.rootVolume.installPath == vmvo.rootVolumes.installPath
    assert cmd.useVirtio
    vmvo.vmNics.each { nic ->
        KVMAgentCommands.NicTO to = cmd.nics.find { nic.mac == it.mac }
        assert to != null: "unable to find the nic[mac:${nic.mac}]"
        assert to.deviceId == nic.deviceId
        assert to.useVirtio
        assert to.nicInternalName == nic.internalName
    }
}
----

测试框架对所有 HTTP
RPC 都注册了返回执行成功的默认 handler。`simulator()` 和 `afterSimulator()` 仅仅改变所关联 EnvSpec 对象上的 agent 逻辑，不影响其它 EnvSpec 对象。

===== simulator() 定义

当我们希望改变测试框架默认 handler 的行为，使用 `simulator()`：

[source,groovy]
----
// httpPath: agent 的 HTTP RPC 路径，例如上例中的 KVM_START_VM_PATH = "/vm/start"
// handler: 处理 HTTP RPC 调用的函数
void simulator(String httpPath, Closure handler)

// handler 作为 groovy Closure 类型可以接收两个可选参数：
// entity：HTTP request，可以获得 HTTP header 和 body
// spec: 该 handler 挂载的 EnvSpec，可以通过它获得其它资源的 spec
// 返回值：返回给 HTTP PRC 调用的 response，如果该 HTTP RPC 不需要返回值，则返回一个空 map：[:] 或 null。
def handler = { HttpEntity<String> entity, EnvSpec spec ->
    return [:]
}
----

===== afterSimulator() 定义

当我们不希望改变测试框架默认 handler 的行为，仅仅希望捕获 HTTP
RPC 命令，或者改变返回的 response 时，用 `afterSimulator()`：

[source,groovy]
----
// httpPath: agent 的 HTTP RPC 路径，例如上例中的 KVM_START_VM_PATH = "/vm/start"
// handler: 需要在系统默认 handler 执行后被调用的函数
void afterSimulator(String httpPath, Closure handler)

// handler 可以接收三个可选参数
// response: 系统默认 handler 返回的 response 对象
// entity：HTTP request，可以获得 HTTP header 和 body
// spec: 该 handler 挂载的 EnvSpec，可以通过它获得其它资源的 spec
// 返回值：返回给 HTTP PRC 调用的 response，如果该 HTTP RPC 不需要返回值，则返回一个空 map：[:] 或 null。
def handler = { Object response, HttpEntity<String> entity, EnvSpec spec ->
    return response
}
----

==== 模拟 HTTP 错误

我们可以在 `simulator()` 和 `afterSimulator()` 函数中抛出 `HttpError` 异常模拟 HTTP 错误，例如：

[source,groovy]
----
env.simulator(KVMConstant.KVM_START_VM_PATH) {
    throw new HttpError(403, "fail to start a VM on purpose")
}
----

==== 捕获消息

我们可以用 `EnvSpec.message()` 捕获一个消息，并模拟消息的行为，例如：

[source,groovy]
----
@Override
void test() {
    ErrorFacade errf = bean(ErrorFacade.class)

    env.message(StartNewCreatedVmInstanceMsg.class) { StartNewCreatedVmInstanceMsg msg, CloudBus bus ->
        def reply = new MessageReply()
        reply.setError(errf.stringToOperationError("on purpose"))
        bus.reply(msg, reply)
    }
}
----

这里我们捕获了 `StartNewCreatedVmInstanceMsg` 消息并制造了一个错误作为消息返回。`message()` 还可以接受一个条件函数用来选择性捕获某些消息，例如：

[source,groovy]
----
@Override
void test() {
    ErrorFacade errf = bean(ErrorFacade.class)

    message(StartNewCreatedVmInstanceMsg.class, { StartNewCreatedVmInstanceMsg msg ->
        return msg.vmInstanceInventory.name == "web"
    }) { StartNewCreatedVmInstanceMsg msg, CloudBus bus ->
        def reply = new MessageReply()
        reply.setError(errf.stringToOperationError("on purpose"))
        bus.reply(msg, reply)
    }
}
----

在这里例子中，只有当 `msg.vmInstanceInventory.name == "web"` 这个条件满足时，消息才会被捕获。

===== message() 定义

[source,groovy]
----
// msgClz: 要捕获消息的类型
// condition: 条件函数，当函数返回 true 时，消息才会被捕获并执行 handler
// handler: 处理被捕获消息的函数
void message(Class<? extends Message> msgClz, Closure condition, Closure handler)

// condition 接收一个可选参数
// msg: 被捕获的消息
// 返回值： true 捕获消息，false 不捕获消息
def condition = { Message msg ->
    return true
}

// handler 接收两个可选参数
// msg: 被捕获的消息
// bus: CloudBus 对象
// 无返回值
def handler = { Message msg, CloudBus bus ->
}
----

==== 执行多个测试场景

用例通常包含多个测试场景，执行时应该按顺序包含在 `EnvSpec.create()` 函数接收的 Closure 中，例如 :

[source,groovy]
----
@Override
void test() {
    env.create {
        testStopVm()
        testStartVm()
        testRebootVm()
        testDestroyVm()
        testRecoverVm()
    }
}
----

=== 销毁测试环境：clean()

每个测试用例都应该在 `clean()` 函数中销毁在 `environment()` 中构建的 `EnvSpec` 对象，例如：

[source,groovy]
----
@Override
void clean() {
    env.delete()
}
----

____
测试用例单独执行时 `clean()` 不会被调用，以留存数据库环境供手动分析
____

== Test Suite

测试用例可以单独执行，也可以放在 test suite 一起执行。test
suite 的作用是只启动一次 JVM 和 ZStack 环境就运行所有测试用例，大大减少测试时间。例如：

[source,groovy]
----
class GetFreeIpTest extends Test {
    def DOC = """

    Test getting free IPs from a single L3 network with one or two IP ranges

"""
    @Override
    void setup() {
        spring {
            include("vip.xml")
        }
    }

    @Override
    void environment() {
    }

    @Override
    void test() {
        runSubCases()
    }
}
----

test suite 的整体结构跟测试用例类似，不同点在于：

[arabic]
. test suite 继承 `Test` 类，测试用例继承 `SubCase` 类
. test
suite 的 `environment()` 通常为空，因为各测试用例会自己创建的 `EnvSpec` 对象
. test suite 在 `test()` 函数中通过 `runSubCases()` 执行一组测试用例
. test suite 没有 `clean()` 函数

测试用例必须保证跟 test
suite 加载相同的服务和组件，以保证用例单独执行和在 test
suite 中执行时 ZStack 运行的组件和服务完全相同。故测试用例应该跟 test
suite 有相同 `setup()` 函数。

*`runSubCases()` 运行时会自动搜索该 test
suite 所在 package 以及子 package 的所有测试用例，无需程序员显示指定。*

=== 运行 Test Suite

运行 test suite 方法跟运行单个测试用例一样：

[source,shell]
----
mvn test -Dtest=GetFreeIpTest
----

=== 指定 Test Suite 输出结果目录

可以使用`-DresultDir` 参数指定 test Suite 输出结果目录，例如：

[source,shell]
----
mvn test -Dtest=GetFreeIpTest -DresultDir=/tmp
----

运行结束后，测试框架会在指定目录建立一个名为 zstack-integration-test-result 的子目录。每个 test
suite 又有一个以 class 全名命名的子目录，例如 `org_zstack_test_integration_kvm_KvmTest`，其中包含一个 summary 文件，包含该 test
suite 运行的总体信息，例如：

[source,json]
----
{"total":1,"success":0,"failure":1,"passRate":0.0}
----

以及以每个测试用例 class 全名命名的结果文件，例如 `org_zstack_test_integration_kvm_lifecycle_OneVmBasicLifeCycleCase.failure`:

[source,json]
----
{"success":false,"error":"unable to find the nic[ip:193.168.100.55]. Expression: (to !\u003d null). Values: to \u003d null","name":"OneVmBasicLifeCycleCase"}
----

文件的后缀名表示测试结果：`success` 为成功，`failure` 为失败。

____
所有文件的内容均为 JSON 格式
____

=== 测试用例间共享 env DSL

相同 test suite 中的测试用例常常需要共享相同的 env
DSL，则可以通过一个类的 static 函数共享，例如：

[source,groovy]
----
class OneVmBasicEnv {
    def DOC = """
use:
1. sftp backup storage
2. local primary storage
3. virtual router provider
4. l2 novlan network
5. security group
"""

    static EnvSpec env() {
        return Test.makeEnv {
            instanceOffering {
                name = "instanceOffering"
                memory = SizeUnit.GIGABYTE.toByte(8)
                cpu = 4
            }

            sftpBackupStorage {
                name = "sftp"
                url = "/sftp"
                username = "root"
                password = "password"
                hostname = "localhost"

                image {
                    name = "image1"
                    url  = "http://zstack.org/download/test.qcow2"
                }

                image {
                    name = "vr"
                    url  = "http://zstack.org/download/vr.qcow2"
                }
            }

            zone {
                name = "zone"
                description = "test"

                cluster {
                    name = "cluster"
                    hypervisorType = "KVM"

                    kvm {
                        name = "kvm"
                        managementIp = "localhost"
                        username = "root"
                        password = "password"
                    }

                    attachPrimaryStorage("local")
                    attachL2Network("l2")
                }

                localPrimaryStorage {
                    name = "local"
                    url = "/local_ps"
                }

                l2NoVlanNetwork {
                    name = "l2"
                    physicalInterface = "eth0"

                    l3Network {
                        name = "l3"

                        service {
                            provider = VirtualRouterConstant.PROVIDER_TYPE
                            types = [NetworkServiceType.DHCP.toString(), NetworkServiceType.DNS.toString()]
                        }

                        service {
                            provider = SecurityGroupConstant.SECURITY_GROUP_PROVIDER_TYPE
                            types = [SecurityGroupConstant.SECURITY_GROUP_NETWORK_SERVICE_TYPE]
                        }

                        ip {
                            startIp = "192.168.100.10"
                            endIp = "192.168.100.100"
                            netmask = "255.255.255.0"
                            gateway = "192.168.100.1"
                        }
                    }

                    l3Network {
                        name = "pubL3"

                        ip {
                            startIp = "12.16.10.10"
                            endIp = "12.16.10.100"
                            netmask = "255.255.255.0"
                            gateway = "12.16.10.1"
                        }
                    }
                }

                virtualRouterOffering {
                    name = "vr"
                    memory = SizeUnit.MEGABYTE.toByte(512)
                    cpu = 2
                    useManagementL3Network("pubL3")
                    usePublicL3Network("pubL3")
                    useImage("vr")
                }

                attachBackupStorage("sftp")
            }

            vm {
                name = "vm"
                useInstanceOffering("instanceOffering")
                useImage("image1")
                useL3Networks("l3")
            }
        }
    }
}

class OneVmBasicLifeCycleCase extends SubCase {
    EnvSpec env

    def DOC = """
test a VM's start/stop/reboot/destroy/recover operations
"""

    @Override
    void environment() {
        env = OneVmBasicEnv.env()
    }
----

上例中 `OneVmBasicEnv` 类中包含了一个公共的 env
DSL，`OneVmBasicLifeCycleCase` 用例在 `environment()` 函数中通过 `OneVmBasicEnv.env()` 构建了一个 EnvSpec 对象。

== Cookbooks

=== 如何在 env DSL 定义资源的时候指定其 UUID

可以通过 `resourceUuid` 参数为 env DSL 定义的资源指定 UUID，例如：

[source,groovy]
----
env = env {
    zone {
        resourceUuid = "14d087f6d59a4d639094e6c2c9032161"
        name = "zone1"
    }
}
----

=== 如何进行级联创建

在某些情况下，我们需要进行资源的级联创建，尤其在 VCenter 和混合云中，我们有大量的 sync 操作 (同步外部资源)。例如：
在添加一个远程的 DataCenter 时，我们需要把该 DataCenter 下的所有 VPC 全部同步过来，而在同步每个 VPC 时，又需要把该 VPC 下的所有 VRouter 同步过来，同样的，在同步 VRouter 时，我们需要同步该 VRouter 下的所有 RouterInterface 以及 RouteEntry 等。
此时，我们要测试程序自动进行级联创建，但又需要传入 VPC、VRouter、RouterInterface 以及 RouteEntry 的相关参数以便模拟。因此我们**不能写成**以下形式 (简化起见，我们只关注 VPC 和 VRouter)：

[source,groovy]
----
            DataCenterSpec dcSpec = dataCenter {
                regionId = "cn-hangzhou"
                type = "aliyun"
                description = "createEcsEnv test"
                dcName = "Test-Region-Name"
                vpc = ecsVpc {
                    vpcName = "Test-Vpc-Name"
                    description = "Test-Vpc"
                    cidrBlock = "192.168.0.0/16"
                    vpcId = "Test-Vpc-Id"
                    VRouterId = "Test-VRouter-Id"
                    vrouter = vRouter {
                        vrId = "Test-VRouter-Id"
                        vRouterName = "Test-VRouter-Name"
                        description = "Test-VRouter"
                    }
                }
                postCreate {
                    attachToOssBucket(ossSpeck.inventory.uuid)
                }
            }
----

写成以上形式会报错，其一是因为测试程序在创建 VRouter 时，缺少 vpcUuid。在创建 VPC 时，又缺少 dataCenterUuid。其二是因为 vRouter 和 VPC 的创建应该由业务逻辑自行完成，而不是用户手工创建
为解决级联创建的问题，我们引入参数”onlyDefine”，默认值为 false。当需要级联创建时，我们只需把以上代码修改为

[source,groovy]
----
            DataCenterSpec dcSpec = dataCenter {
                regionId = "cn-hangzhou"
                type = "aliyun"
                description = "createEcsEnv test"
                dcName = "Test-Region-Name"
                vpc = ecsVpc {
                    onlyDefine = true   // 只需在这里设置 true 即可
                    vpcName = "Test-Vpc-Name"
                    description = "Test-Vpc"
                    cidrBlock = "192.168.0.0/16"
                    vpcId = "Test-Vpc-Id"
                    VRouterId = "Test-VRouter-Id"
                    vrouter = vRouter {
                        onlyDefine = true    // 只需在这里设置 true 即可
                        vrId = "Test-VRouter-Id"
                        vRouterName = "Test-VRouter-Name"
                        description = "Test-VRouter"
                    }
                }
                postCreate {
                    attachToOssBucket(ossSpeck.inventory.uuid)
                }
            }
----

然后，在相应的 Spec 文件中，我们定义一个 define 函数，如：

[source,groovy]
----
(in EcsVpcSpec.groovy)
    @Override
    SpecID define(String uuid) {
        inventory = new EcsVpcInventory()
        inventory.uuid = uuid
        inventory.vpcName = vpcName
        inventory.ecsVpcId = vpcId
        inventory.cidrBlock = cidrBlock
        inventory.description = description
        inventory.vRouterId = VRouterId
        inventory.status = "Available"

        return id(inventory.vpcName, inventory.uuid)
    }
----

以及

[source,groovy]
----
(in VRouterSpec.groovy)
    @Override
    SpecID define(String uuid) {
        inventory = new VpcVirtualRouterInventory()
        inventory.uuid = uuid
        inventory.vRouterName = vRouterName
        inventory.description = description
        inventory.vrId = vrId
        return id(inventory.vRouterName, inventory.uuid)
    }
----

如此以来，测试程序就创建出了相应的 inventory，以便 simulator 使用，而不会去尝试写数据库。(写数据库操作应该由业务逻辑自行完成)
测试程序在创建 dataCenter 的时候，若要同步 VPC，那么会发出一个 SyncVpcPropertyMsg，测试程序捕捉到后，可以对其进行如下模拟，此时由于 inventory 己经被 define 了，所以该 simulator 可以通过

[source,groovy]
----
(in VRouterSpec.groovy)
    private void setupSimulator() {
        message(SyncVpcPropertyMsg.class) { SyncVpcPropertyMsg msg, CloudBus bus ->
            SyncVpcPropertyReply reply = new SyncVpcPropertyReply()
            def property = new EcsVpcProperty()
            property.ecsVpcId = inventory.ecsVpcId
            property.status = inventory.status
            property.vpcName = inventory.vpcName
            property.cidrBlock = inventory.cidrBlock
            property.vRouterId = inventory.vRouterId
            property.description = inventory.description
            reply.setVpcs(Arrays.asList(property))
            bus.reply(msg, reply)
        }
    }
----

=== 如何在获得 env DSL 中定义的资源的 spec

env DSL 中定义的资源可以通过名字和 UUID 两种方式引用。例如：

[source,groovy]
----
    @Override
    void test() {
        // envSpec 为 env DSL 创建的 EnvSpec 对象
        envSpec.create {
            DiskOfferingSpec diskOfferingSpec = envSpec.specByName("diskOffering")
            ZoneSpec zone = envSpec.specsByUuid("14d087f6d59a4d639094e6c2c9032161")
        }
    }
----

env
DSL 描述资源时应该为每个资源赋予一个全局唯一的名字，以保证通过 `specByName()` 能引用到正确的资源。使用 `specsByUuid()` 引用资源时应保证该资源在 env
DSL 中使用了 `resourceUuid` 参数指定 UUID。

每个资源的 spec 对象都包含一个 `inventory` 字段，对应该资源在 SDK 中的 inventory 类，例如 `ZoneSpec.inventory` 类型为 `org.zstack.sdk.ZoneInventory`。

____
注意：SDK 中的 inventory 类命名跟 ZStack header
package 中的 inventory 类命名一样，因为 SDK 是通过 ZStack 源码生成的。在写测试用时，应注意不要错误的 import 了 header
package 中的 inventory 类而引发类型错误。测试用例应该只使用 SDK 中的 inventory 类。
____

=== 如何获取已加载的组件

可以通过 `bean()` 函数获得加载的 ZStack 组件，例如：

[source,groovy]
----
@Override
void test() {
    ErrorFacade errf = bean(ErrorFacade.class)
    DatabaseFacade dbf = bean(DatabaseFacade.class)
}
----

=== DatabaseFacade.findByUuid() 快捷函数

可以通过 `dbFindByUuid()` 函数方便的通过 UUID 查询一个资源的数据库 VO 对象，例如：

[source,groovy]
----
void testStartVm() {
    VmInstanceVO vmvo = dbFindByUuid(cmd.vmInstanceUuid, VmInstanceVO.class)
    assert vmvo.state == VmInstanceState.Running
}
----

相当于：

[source,groovy]
----
void testStartVm() {
    DatabaseFacade dbf = bean(DatabaseFacade.class)
    VmInstanceVO vmvo = dbf.findByUuid(cmd.vmInstanceUuid, VmInstanceVO.class)
    assert vmvo.state == VmInstanceState.Running
}
----

=== 如何清理加载的 simulator/message 的 handler

可以直接调用下列函数清除前面测试函数加载的 simulator 或 message 加载的 handler:

[source,groovy]
----
// env 为 EnvSpec 对象

env.cleanSimulatorAndMessageHandlers()
env.cleanSimulatorHandlers()
env.cleanAfterSimulatorHandlers()
env.cleanMessageHandlers()
----

=== JSON 快捷函数

可以直接使用 `json()` 函数将 json 字符串转换成对象：

[source,groovy]
----
        env.afterSimulator(FlatUserdataBackend.RELEASE_USER_DATA) { rsp, HttpEntity<String> e ->
            cmd = json(e.body, FlatUserdataBackend.ReleaseUserdataCmd.class)
            return rsp
        }
----

=== 应该在哪里修改 Global Config

当一个 case 需要修改 global
config 时，只能在 `EnvSpec.create()` 函数后的 \{}中，因为当 create 函数执行时会重置所有 global
config 到默认值。例如：

[source,groovy]
----
  @Override
    void test() {
        env.create {
            // Global Config 必须在这里修改
            // make the interval very long, we use api to trigger the job to test
            ImageGlobalConfig.DELETION_GARBAGE_COLLECTION_INTERVAL.updateValue(TimeUnit.DAYS.toSeconds(1))

            testImageGCWhenBackupStorageDisconnect()

            env.recreate("image")

            testImageGCCancelledAfterBackupStorageDeleted()
        }
    }
----

=== 如何重建一个被删除的资源，该资源是用 `environment()` 构造的

有时候我们测试用例会删除一些资源做测试，而这些资源又是 `environment()` 构造的包含在 `EnvSpec` 对象中的资源。当用例中后面的测试函数需要用到这些资源时，重建是件非常麻烦的事情，这时可以用 `EnvSpec.recreate()` 函数重建该资源，例如：

[source,groovy]
----
    @Override
    void test() {
        env.create {
            testGCSuccess()
            testGCCancelledAfterHostDeleted()

            // 这里 testGCCancelledAfterHostDeleted() 删除了名为 kvm 的 host，我们
            // 用 env.recreate() 重建它供 testGCCancelledAfterPrimaryStorageDeleted() 使用
            env.recreate("kvm")

            testGCCancelledAfterPrimaryStorageDeleted()
        }
    }
----

`EnvSpec.recreate()` 会重建资源以及它的子资源。

=== 获得一个资源的 inventory 对象

可以直接通过 `EnvSpec.inventoryByName()` 获得一个已创建资源的 inventory 对象 (org.zstack.sdk.xxxInventory,
例如 org.zstack.sdk.ImageInventory)。举例：

[source,groovy]
----
/*
EnvSpec env = env {
        zone {
            name = "zone"
        }

        sftpBackupStorage {
            name = "sftp"
            url = "/sftp"

            image {
                name = "image"
                url = "http://zstack.org/download/image.qcow2"
            }
        }
}
*/

ImageInventory image = env.inventoryByName("image")
----

=== 使用 `retryInSecs` 和 `retryInMillis` 检验异步操作结果

当某些操作异步执行时（例如删除虚拟机后，归还磁盘容量的就是异步操作），我们需要等待一段时间确保异步操作完成再检验结果，可以使用 `retryInXxx` 函数不断检测异步操作是否完成，具体使用方式见下例：

[source,groovy]
----
    boolean ret = retryInSecs(3, 1) {
        // 在这里执行操作结果检测
        // 检测成功返回 true，则 retryInSecs 会直接返回 true，表示检测成功；
        // 返回 false，retryInSecs 会 sleep 指定 interval 后（第二个参数，这里为 1s）后再次执行该检测函数。
        // 如果在指定间隔时间（第一个参数，这里为 3s) 检测函数都返回 false，retryInSecs 返回 false，表示检测失败
        return true
    }
----

同样可以用 `retryInMillis()` 进行毫秒级的循环检测。

=== 查看失败 case log

Test Suite 运行时会将失败 case 的 log 以及当时的 DB
dump 保存到 `zstack-integration-test-result/TEST-SUITE-DIR/failureLogs/CASE-NAME` 目录，例如

....
[root@localhost:/root/zstack/test]# ls zstack-integration-test-result/org_zstack_test_integration_network_NetworkTest/failureLogs/org_zstack_test_integration_network_vxlanNetwork_OneVxlanNetworkLifeCycleCase/
case.log  dbdump.sql
....

=== 获取 Test Suite 测试用例列表

运行 test suite 时指定`-Dlist` 参数可以获取测试用例列表，例如：

[source,shell]
----
mvn test -Dtest=KvmTest -Dlist
----

列表输出在对应 test suite 结果目录的 `cases` 文件中，例如：

[source,shell]
----
[root@localhost:/root/zstack/test]# cat zstack-integration-test-result/org_zstack_test_integration_kvm_KvmTest/cases
org.zstack.test.integration.kvm.host.HostStateCase
org.zstack.test.integration.kvm.status.MaintainHostCase
org.zstack.test.integration.kvm.vm.VmConsoleCase
org.zstack.test.integration.kvm.hostallocator.LeastVmPreferredAllocatorCase
org.zstack.test.integration.kvm.vm.VmGCCase
org.zstack.test.integration.kvm.vm.OneVmBasicLifeCycleCase
org.zstack.test.integration.kvm.globalconfig.KvmGlobalConfigCase
org.zstack.test.integration.kvm.vm.UpdateVmCase
org.zstack.test.integration.kvm.status.DBOnlyCase
org.zstack.test.integration.kvm.capacity.CheckHostCapacityWhenAddHostCase
----

=== 使用`-Dapipath` 参数打印 API 调用的 call graph

在运行一个测试用例时指定`-Dapipath` 参数可以打印出用例运行中所有 API（不包含读 API，例如 query/get
API）引发的消息和 HTTP RPC call，从而对每个 API 的 call
graph 有个大致的了解。例如：

[source,shell]
----
mvn  test -Dtest=OneVmBasicLifeCycleCase -Dapipath
----

用例运行成功并退出后，call
graph 文件生成在 `zstack-integration-test-result/apipath` 目录：

....
[root@localhost:/root/zstack/test/zstack-integration-test-result/apipath]# ls
org_zstack_sdk_AddImageAction                         org_zstack_sdk_CreateDiskOfferingAction           org_zstack_sdk_DestroyVmInstanceAction
org_zstack_sdk_AddIpRangeAction                       org_zstack_sdk_CreateInstanceOfferingAction       org_zstack_sdk_RebootVmInstanceAction
org_zstack_sdk_AddKVMHostAction                       org_zstack_sdk_CreateL2NoVlanNetworkAction        org_zstack_sdk_RecoverVmInstanceAction
org_zstack_sdk_AddLocalPrimaryStorageAction           org_zstack_sdk_CreateL3NetworkAction              org_zstack_sdk_StartVmInstanceAction
org_zstack_sdk_AddSftpBackupStorageAction             org_zstack_sdk_CreateVirtualRouterOfferingAction  org_zstack_sdk_StopVmInstanceAction
org_zstack_sdk_AttachNetworkServiceToL3NetworkAction  org_zstack_sdk_CreateVmInstanceAction
org_zstack_sdk_CreateClusterAction                    org_zstack_sdk_CreateZoneAction

[root@localhost:/root/zstack/test/zstack-integration-test-result/apipath]# cat org_zstack_sdk_CreateVmInstanceAction
(Message) org.zstack.header.vm.APICreateVmInstanceMsg --->
(Message) org.zstack.header.vm.StartNewCreatedVmInstanceMsg --->
(Message) org.zstack.header.allocator.DesignatedAllocateHostMsg --->
(Message) org.zstack.header.storage.primary.AllocatePrimaryStorageMsg --->
(Message) org.zstack.header.volume.CreateVolumeMsg --->
(Message) org.zstack.header.network.l3.AllocateIpMsg --->
(Message) org.zstack.header.volume.InstantiateRootVolumeMsg --->
(Message) org.zstack.header.storage.primary.InstantiateRootVolumeFromTemplateOnPrimaryStorageMsg --->
(Message) org.zstack.header.storage.primary.AllocatePrimaryStorageMsg --->
(Message) org.zstack.storage.backup.sftp.GetSftpBackupStorageDownloadCredentialMsg --->
(Message) org.zstack.network.service.virtualrouter.CreateVirtualRouterVmMsg --->
(Message) org.zstack.appliancevm.StartNewCreatedApplianceVmMsg --->
(Message) org.zstack.header.allocator.DesignatedAllocateHostMsg --->
(Message) org.zstack.header.storage.primary.AllocatePrimaryStorageMsg --->
(Message) org.zstack.header.volume.CreateVolumeMsg --->
(Message) org.zstack.header.network.l3.AllocateIpMsg --->
(Message) org.zstack.header.network.l3.AllocateIpMsg --->
(Message) org.zstack.header.volume.InstantiateRootVolumeMsg --->
(Message) org.zstack.header.storage.primary.InstantiateRootVolumeFromTemplateOnPrimaryStorageMsg --->
(Message) org.zstack.header.storage.primary.AllocatePrimaryStorageMsg --->
(Message) org.zstack.storage.backup.sftp.GetSftpBackupStorageDownloadCredentialMsg --->
(Message) org.zstack.header.vm.CreateVmOnHypervisorMsg --->
(HttpRPC) [url:http://localhost:8989/vm/start, cmd: org.zstack.kvm.KVMAgentCommands$StartVmCmd] --->
(Message) org.zstack.appliancevm.ApplianceVmRefreshFirewallMsg --->
(HttpRPC) [url:http://localhost:8989/appliancevm/refreshfirewall, cmd: org.zstack.appliancevm.ApplianceVmCommands$RefreshFirewallCmd] --->
(Message) org.zstack.appliancevm.ApplianceVmRefreshFirewallMsg --->
(HttpRPC) [url:http://localhost:8989/appliancevm/refreshfirewall, cmd: org.zstack.appliancevm.ApplianceVmCommands$RefreshFirewallCmd] --->
(HttpRPC) [url:http://localhost:8989/init, cmd: org.zstack.network.service.virtualrouter.VirtualRouterCommands$InitCommand] --->
(Message) org.zstack.header.vm.CreateVmOnHypervisorMsg --->
(HttpRPC) [url:http://localhost:8989/vm/start, cmd: org.zstack.kvm.KVMAgentCommands$StartVmCmd] --->
(Message) org.zstack.network.securitygroup.RefreshSecurityGroupRulesOnVmMsg
....

=== 新的测试用例应该加到哪儿

新的测试用例都应该加到 `test/src/test/groovy/org/zstack/test/integration/` 目录，目前已定义如下几大类 test
suite：

[arabic]
. *org.zstack.test.integration.configuration.ConfigurationTest.groovy*:
+
所有配置相关的测试，包括 instance offering, disk offering，global
config 的通用 API
. *org.zstack.test.integration.kvm.KvmTest.groovy*:
+
所有跟 zone、cluster、host、host allocator、vm 相关的通用测试
. *org.zstack.test.integration.network.NetworkTest.groovy*:
+
除网络服务外（例如 eip）的所有跟 l2、l3 网络，ip range 相关的测试
. *org.zstack.test.integration.networkservice.provider.NetworkServiceProviderTest.groovy*:
+
所有跟网络服务 (eip，dhcp 等）相关的测试
. *org.zstack.test.integration.storage.StorageTest.groovy*:
+
所有跟存储相关的测试，包括 primary storage、backup
storage、volume、volume snapshot

下图包含所有已定义测试目录分类：

....
└── org
    └── zstack
        └── test
            └── integration
                ├── configuration
                │   ├── ConfigurationTest.groovy
                │   ├── diskoffering
                │   └── instanceoffering
                ├── kvm
                │   ├── Env.groovy
                │   ├── hostallocator
                │   ├── KvmTest.groovy
                │   └── lifecycle
                │       └── OneVmBasicLifeCycleCase.groovy
                ├── network
                │   ├── l2network
                │   ├── l3network
                │   │   └── getfreeip
                │   │       ├── OneL3OneIpRangeNoIpUsed.groovy
                │   │       ├── OneL3OneIpRangeSomeIpUsed.groovy
                │   │       └── OneL3TwoIpRanges.groovy
                │   └── NetworkTest.groovy
                ├── networkservice
                │   └── provider
                │       ├── flat
                │       │   ├── dhcp
                │       │   │   └── OneVmDhcp.groovy
                │       │   ├── eip
                │       │   ├── Env.groovy
                │       │   └── userdata
                │       │       └── OneVmUserdata.groovy
                │       ├── NetworkServiceProviderTest.groovy
                │       ├── securitygroup
                │       └── virtualrouter
                │           ├── dhcp
                │           ├── dns
                │           ├── eip
                │           ├── lb
                │           ├── portforwarding
                │           ├── snat
                │           └── VirtualRouterProviderTest.groovy
                └── storage
                    ├── backup
                    │   ├── ceph
                    │   └── sftp
                    ├── primary
                    │   ├── ceph
                    │   ├── local
                    │   ├── nfs
                    │   └── smp
                    ├── StorageTest.groovy
                    ├── volume
                    └── volumesnapshot
....
